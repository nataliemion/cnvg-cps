# -*- coding: utf-8 -*-
"""Escala_Kids.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YKCrKk8m_Dn0K-Y07NBbZ2asEBjTaksa
"""

import pandas as pd
from datetime import date, timedelta
import random

# ----------------------------------------------------------------------
# 1. Configura√ß√µes e Carregamento de Dados
# ----------------------------------------------------------------------

# Nome do arquivo CSV que voc√™ fez upload no Colab
NOME_ARQUIVO_CSV = 'Escala KIDS_NomesLista.csv'
df_voluntarios = pd.read_csv(NOME_ARQUIVO_CSV)

# Limpeza de espa√ßos (strip) em todas as colunas de texto (Corre√ß√£o de KeyError anterior)
df_voluntarios['NOME'] = df_voluntarios['NOME'].str.strip()
df_voluntarios['SALA ATRIBU√çDA'] = df_voluntarios['SALA ATRIBU√çDA'].str.strip()
df_voluntarios['Sexo'] = df_voluntarios['Sexo'].str.strip()

# Define o per√≠odo da escala (Janeiro a Julho de 2026)
START_DATE = date(2026, 1, 1)
END_DATE = date(2026, 7, 31)
MIN_ESCALAS = 6 # NOVA REGRA: M√≠nimo de escalas por pessoa

# Lista de todas as salas
SALAS = ['MATERNAL', 'KINDER', 'Kids 1 (6-8)', 'Kids 2 (9-11)']

# Regras de Reforma (Kids 1 e Kids 2 indispon√≠veis em Janeiro/2026)
REFORMA_FIM = date(2026, 1, 31)

# Intervalo m√≠nimo de folga em dias (2 domingos = 14 dias)
INTERVALO_MINIMO_DIAS = 14

# ----------------------------------------------------------------------
# 2. Pr√©-processamento e Gera√ß√£o de Datas
# ----------------------------------------------------------------------

def gerar_domingos(start_date, end_date):
    """Gera uma lista de todas as datas de domingo no per√≠odo."""
    datas = []
    current_date = start_date
    # Encontra o primeiro domingo
    while current_date.weekday() != 6: # 6 √© Domingo
        current_date += timedelta(days=1)

    # Adiciona os domingos subsequentes
    while current_date <= end_date:
        datas.append(current_date)
        current_date += timedelta(days=7)
    return datas

datas_escala = gerar_domingos(START_DATE, END_DATE)

# Cria um dicion√°rio de volunt√°rios por sala e g√™nero
voluntarios_por_sala = {sala: {'Feminino': [], 'Masculino': []} for sala in SALAS}

for index, row in df_voluntarios.iterrows():
    sala = row['SALA ATRIBU√çDA']
    genero = row['Sexo']
    nome = row['NOME']

    if sala in voluntarios_por_sala and genero in voluntarios_por_sala[sala]:
        voluntarios_por_sala[sala][genero].append(nome)

# Cria√ß√£o limpa do registro de trabalho (rastreia o √∫ltimo domingo trabalhado)
todos_nomes_unicos = df_voluntarios['NOME'].unique()
ultimo_trabalho = {nome: date(1900, 1, 1) for nome in todos_nomes_unicos}

# Rastreia o n√∫mero de vezes que cada pessoa foi escalada (Para a Nova Regra)
contagem_escala = {nome: 0 for nome in todos_nomes_unicos}

escala = {sala: {} for sala in SALAS}

# ----------------------------------------------------------------------
# 3. Fun√ß√£o Principal de Agendamento
# ----------------------------------------------------------------------

def agendar_sala(data, sala, escala_atual, ult_trab_restrito, ultimo_trabalho_global, contagem_escala_global):
    """
    Tenta agendar 2 professores (P1 e P2) para a sala, respeitando todas as regras.
    """

    # 1. Checagem de Reforma (Regra 2)
    if sala in ['Kids 1 (6-8)', 'Kids 2 (9-11)'] and data <= REFORMA_FIM:
        escala_atual[sala][data] = ['FECHADO (REFORMA)', 'FECHADO (REFORMA)']
        return []

    # 2. Defini√ß√£o de Volunt√°rios Potenciais
    v_sala = voluntarios_por_sala.get(sala, {'Feminino': [], 'Masculino': []})
    candidatos_validos = []

    # Filtra candidatos pelo intervalo m√≠nimo (Regras 3 e 5) e ocupa√ß√£o no dia (Regra 4)
    for genero, lista_nomes in v_sala.items():
        for nome in lista_nomes:
            # Checa se respeita o intervalo de 2 domingos
            if (data - ultimo_trabalho_global[nome]).days > INTERVALO_MINIMO_DIAS:
                # Checa se n√£o foi marcado como ocupado HOJE (dupla atribui√ß√£o)
                if (data - ult_trab_restrito[nome]).days > 0:
                    # Inclui a contagem atual para fins de prioriza√ß√£o
                    contagem = contagem_escala_global[nome]
                    candidatos_validos.append((contagem, nome, genero))

    # 3. Tentativa de Agendamento (P1 e P2)
    escalados_na_data = []

    # Prioriza√ß√£o (NOVA L√ìGICA): Ordena os candidatos. Prioriza menor contagem (contagem), depois aleat√≥rio (random.random())
    # Isso garante que quem trabalhou menos tem mais chance.
    candidatos_validos = sorted(candidatos_validos, key=lambda x: (x[0], random.random()))

    for pos in ['P1', 'P2']:

        # Filtra os candidatos dispon√≠veis para esta data
        # c[1] √© o nome do volunt√°rio
        candidatos_disp = [c for c in candidatos_validos if c[1] not in [n for c, n, g in escalados_na_data]]

        # Filtra por g√™nero (Regra 7: Garante m√°ximo 1 Masculino)
        if pos == 'P2':
            p1_escalado = escala_atual[sala].get(data, [None])[0]

            if p1_escalado is not None:
                # Encontra o g√™nero do P1 que acabamos de escalar
                p1_genero = next((g for c, n, g in escalados_na_data if n == p1_escalado), None)

                if p1_genero == 'Masculino':
                    # c[2] √© o g√™nero
                    candidatos_disp = [c for c in candidatos_disp if c[2] == 'Feminino']

        # Tenta selecionar o primeiro candidato dispon√≠vel
        if candidatos_disp:
            # Seleciona (contagem, nome, genero)
            selecionado_info = candidatos_disp[0]
            selecionado = selecionado_info[1] # Nome
            genero = selecionado_info[2] # G√™nero

            escalados_na_data.append(selecionado_info)

            # Atualiza a escala
            if data not in escala_atual[sala]:
                escala_atual[sala][data] = [None, None]

            idx = 0 if pos == 'P1' else 1
            escala_atual[sala][data][idx] = selecionado

        else:
            pass

    # 4. Checagem de Falha: Se n√£o conseguiu 2 pessoas (Regra 6)
    if data not in escala_atual[sala] or escala_atual[sala][data][0] is None or escala_atual[sala][data][1] is None:
        # Reverte agendamentos parciais e marca como falha
        escala_atual[sala][data] = ['FALTA DE VOLUNT√ÅRIO', 'FALTA DE VOLUNT√ÅRIO']
        return []

    # Retorna apenas os nomes dos escalados com sucesso
    return [n for c, n, g in escalados_na_data]

# ----------------------------------------------------------------------
# 4. Gera√ß√£o da Escala (Itera√ß√£o por Salas e Datas)
# ----------------------------------------------------------------------

for data in datas_escala:

    salas_hoje = ['MATERNAL', 'KINDER', 'Kids 1 (6-8)', 'Kids 2 (9-11)']
    random.shuffle(salas_hoje)

    voluntarios_ocupados_hoje = set()

    for sala in salas_hoje:

        # Cria uma c√≥pia tempor√°ria de 'ultimo_trabalho' para restringir quem j√° foi escalado HOJE.
        ult_trab_restrito = ultimo_trabalho.copy()
        for nome_ocupado in voluntarios_ocupados_hoje:
             ult_trab_restrito[nome_ocupado] = data

        # Tenta agendar, passando o dicion√°rio de contagem para prioriza√ß√£o
        escalados_sala = agendar_sala(data, sala, escala, ult_trab_restrito, ultimo_trabalho, contagem_escala)

        # Atualiza os registros globais apenas com os escalados com sucesso
        for nome_escalado in escalados_sala:
            voluntarios_ocupados_hoje.add(nome_escalado)

            # üí° Atualiza o √∫ltimo trabalho (para intervalo de 2 domingos)
            ultimo_trabalho[nome_escalado] = data

            # üí° Atualiza a contagem de escalas (Para a NOVA REGRA)
            contagem_escala[nome_escalado] = contagem_escala.get(nome_escalado, 0) + 1

# ----------------------------------------------------------------------
# 5. Formata√ß√£o da Sa√≠da (CSV)
# ----------------------------------------------------------------------

# Monta o DataFrame final
df_final = []
funcoes = ['P1', 'P2']

for sala in SALAS:
    for i, funcao in enumerate(funcoes):
        linha = {'SALA': sala, 'FUN√á√ÉO': funcao}
        for data in datas_escala:
            data_str = data.strftime('%d/%m/%Y')

            if sala in escala and data in escala[sala]:
                nome = escala[sala][data][i] if len(escala[sala][data]) > i else 'N/A'
            else:
                 nome = 'N/A'

            linha[data_str] = nome

        df_final.append(linha)

df_escala = pd.DataFrame(df_final)

data_cols_formatadas = [d.strftime('%d/%m/%Y') for d in datas_escala]

# CORRE√á√ÉO: Reordena as colunas
df_escala = df_escala[['SALA', 'FUN√á√ÉO'] + data_cols_formatadas]

# ----------------------------------------------------------------------
# 6. Relat√≥rio de Conformidade (Nova Regra - M√≠nimo de 6x)
# ----------------------------------------------------------------------

print("\n" + "="*80)
print("--- RELAT√ìRIO DE FREQU√äNCIA DE ESCALA (M√≠nimo de 6x) ---".center(80))
print("="*80)

# Cria o DataFrame de contagem para o relat√≥rio
df_contagem = pd.DataFrame(list(contagem_escala.items()), columns=['NOME', 'Contagem'])
df_contagem['Alcan√ßou M√≠nimo (6x)'] = df_contagem['Contagem'] >= MIN_ESCALAS

# Imprime a tabela ordenada pela menor contagem
print("Contagem de escalas por volunt√°rio:")
print(df_contagem.sort_values(by='Contagem', ascending=True).to_string(index=False))

nao_alcancaram = df_contagem[df_contagem['Contagem'] < MIN_ESCALAS]
if nao_alcancaram.empty:
    print("\n‚úÖ Todos os volunt√°rios alcan√ßaram ou excederam o m√≠nimo de 6 escalas.")
else:
    print(f"\n‚ö†Ô∏è ATEN√á√ÉO: {len(nao_alcancaram)} volunt√°rios N√ÉO alcan√ßaram o m√≠nimo de 6 escalas.")
    print("Isso geralmente ocorre devido a alta satura√ß√£o de salas espec√≠ficas (g√™nero/demanda) ou falta de vagas dispon√≠veis.")

print("="*80)

# ----------------------------------------------------------------------
# 7. Gera√ß√£o do Arquivo CSV
# ----------------------------------------------------------------------

NOME_ARQUIVO_FINAL = 'escala_kids_2026.csv'
df_escala.to_csv(NOME_ARQUIVO_FINAL, index=False)

print(f"\n‚úÖ Escala gerada com sucesso: '{NOME_ARQUIVO_FINAL}'")
print("O arquivo foi salvo no ambiente do Colab e est√° pronto para download.")